#!/usr/bin/env node
// Generated by CoffeeScript 1.11.1
(function() {
  var Promise, background, bold, collect, color, colorNames, cols, doColor, fs, getStdin, j, len, normal, oneOf, parseOpts, parseRGBA, pkg, program, sh2png,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    hasProp = {}.hasOwnProperty;

  Promise = require("bluebird");

  fs = Promise.promisifyAll(require("fs"));

  pkg = require("../package");

  sh2png = require("./sh2png");

  colorNames = ["default", "red", "green", "yellow", "blue", "magenta", "cyan", "white"];

  program = require("commander");

  program.version(pkg.version);

  collect = function(val, memo) {
    if (memo == null) {
      memo = [];
    }
    memo.push(val);
    return memo;
  };

  parseRGBA = function(val) {
    var a, b, colors, g, i, j, len, out, r, ref, ref1, v;
    switch (false) {
      case val.indexOf("0x") !== 0:
        return parseInt(val, 16);
      case !(val.indexOf(",") > -1 && (colors = val.split(",")).length > 2):
        colors = val.split(",");
        out = [];
        ref = ["r", "g", "b", "a"];
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          v = ref[i];
          if (v === "a" && !colors[i]) {
            colors[i] = "FF";
          }
          colors[i] = parseInt(colors[i], 16);
          if (!((0 <= (ref1 = colors[i]) && ref1 <= 255))) {
            throw new RangeError("RGBA component " + v + " must be between 0 and 255, given " + colors[i] + " in color " + val);
          }
        }
        r = colors[0], g = colors[1], b = colors[2], a = colors[3];
        return (1 << 34) + (r << 24) + (g << 16) + (b << 8) + a;
      default:
        throw new RangeError("Misformatted color " + val + ".  Try providing in the format 0xRRGGBBAA or RR,GG,BB[,AA].");
    }
  };

  oneOf = function() {
    var option, options;
    option = arguments[0], options = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return function(input) {
      if (indexOf.call(options, input) >= 0) {
        return input;
      }
      if (input && input.length > 1) {
        throw new RangeError("Invalid option '" + input + "' for " + option + ".  Must be one of " + (options.join(", ")));
      }
      throw new RangeError("Missing input for option '" + option + "'.  Must be one of " + (options.join(", ")));
    };
  };

  doColor = function(color, bold) {
    var b, c, code, n, ref;
    if (bold == null) {
      bold = true;
    }
    code = null;
    ref = sh2png.colorCodes;
    for (c in ref) {
      if (!hasProp.call(ref, c)) continue;
      n = ref[c];
      if (n === color) {
        code = c;
      }
    }
    if (!(color && code)) {
      return color;
    }
    b = bold ? "\x1b[1m" : "";
    return b + "\x1b[" + code + "m" + color + "\x1b[0m";
  };


  /*
  Convert raw options into supported options by sh2png, including converting colors from flat options into an object.
   */

  parseOpts = function(options) {
    var base, base1, internal, name, opt, output, val;
    output = {};
    internal = ["commands", "options", "Command", "Option", "executables", "rawArgs", "args", "domain"];
    for (opt in options) {
      val = options[opt];
      switch (false) {
        case opt !== "background":
          if (output.colors == null) {
            output.colors = {};
          }
          output.colors.background = val;
          break;
        case opt.indexOf("bold") !== 0:
          name = opt.replace("bold", "").toLowerCase();
          if (output.colors == null) {
            output.colors = {};
          }
          if ((base = output.colors).bold == null) {
            base.bold = {};
          }
          output.colors.bold[name] = val;
          break;
        case indexOf.call(colorNames, opt) < 0:
          if (output.colors == null) {
            output.colors = {};
          }
          if ((base1 = output.colors).normal == null) {
            base1.normal = {};
          }
          output.colors.normal[opt] = val;
          break;
        case !(indexOf.call(internal, opt) < 0 && opt.indexOf("_") !== 0 && typeof val !== "function"):
          output[opt] = val;
      }
    }
    return output;
  };


  /*
  @return {Promise<String>} all stdin input as a utf8 string.
   */

  getStdin = function() {
    process.stdin.setEncoding("utf8");
    return new Promise(function(resolve, reject) {
      var data;
      data = "";
      process.stdin.on("readable", function() {
        var chunk, results;
        results = [];
        while (chunk = process.stdin.read()) {
          results.push(data += chunk);
        }
        return results;
      });
      return process.stdin.on("end", function() {
        return resolve(data);
      });
    });
  };

  cols = process.stdout.columns;

  program.option("-w, --width <n>", "The console width.  Defaults to terminal width (" + cols + ")", parseInt, cols);

  program.option("--font <path>", "A path to a BMFont file to use.  Can be used more than once.  Defaults to Ubuntu Mono, 16pt.", collect, null);

  program.option("-f, --format <format>", "File format to output.  Valid options: png, jpeg, bmp.  Defaults to extension of filename if given, otherwise 'png'", oneOf("format", "png", "jpg", "bmp"), "png");

  program.option("-o, --output <file>", "Path to store the output file.  If not given, outputs to stdout.");

  program.option("--base64", "Output a base64 encoded image, instead of a binary file.  Explicit output format is required.");

  for (j = 0, len = colorNames.length; j < len; j++) {
    color = colorNames[j];
    normal = sh2png.colorScheme.normal[color];
    bold = sh2png.colorScheme.bold[color];
    program.option("--" + color + " <hex>", "Set the output color for " + (doColor(color, false)) + " text.  RGBA value.  Default: 0x" + (normal.toString(16).toUpperCase()), parseRGBA, normal);
    program.option("--bold-" + color + " <hex>", "Set the output color for bold " + (doColor(color)) + " text.  RGBA value.  Default: 0x" + (bold.toString(16).toUpperCase()), parseRGBA, bold);
  }

  background = sh2png.colorScheme.background;

  program.option("--background", "Set the background color.  RGBA value.  Default: 0x" + (background.toString(16).toUpperCase()), parseRGBA, background);

  program.command("piped").alias("-").description("Format text piped into the command").action(function(opts) {
    var options, promise;
    options = parseOpts(program);
    promise = Promise.resolve();
    return promise.then(function() {
      return getStdin();
    }).then(function(stdin) {
      return sh2png.format(stdin, options);
    }).then(function(image) {
      var mime;
      if (options.base64) {
        mime = options.format ? "image/" + options.format : "image/png";
        return image.getBase64Async(mime).then(function(base64) {
          if (options.output) {
            return fs.writeFileAsync(options.output, base64);
          } else {
            return console.log(base64);
          }
        });
      } else {
        if (options.output) {
          return image.write(options.output);
        } else {
          if (options.format && options.format === "jpg") {
            options.format = "jpeg";
          }
          mime = options.format ? "image/" + options.format : "image/png";
          return new Promise(function(resolve, reject) {
            return image.getBuffer(mime, function(err, buffer) {
              if (err) {
                return reject(err);
              }
              process.stdout.write(buffer);
              return resolve();
            });
          });
        }
      }
    }).then(function() {
      if (options.output) {
        return console.log("Wrote " + options.output + ".");
      }
    })["catch"](function(err) {
      console.error("Error while formatting input.");
      return console.error(err);
    });
  });

  program.parse(process.argv);

}).call(this);
